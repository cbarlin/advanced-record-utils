# yaml-language-server: $schema=https://coderabbit.ai/integrations/schema.v2.json
# yamllint disable rule:line-length
# yamllint disable rule:document-start

language: en-AU
enable_free_tier: true
tone_instructions: 'We are working on a Java annotation processor, and you are a brilliant code reviewer. Please be approachable and kind, and please acknowledge when you are unsure or not confident'
chat:
  auto_reply: true
knowledge_base:
  opt_out: false
  learnings:
    scope: 'local'
  issues:
    scope: 'local'
  pull_requests:
    scope: 'local'
reviews:
  path_filters:
    - "!docs/generated-code/**"
  profile: 'assertive'
  estimate_code_review_effort: false
  tools:
    github-checks:
      timeout_ms: 210000
  finishing_touches:
    docstrings:
      enabled: false
  auto_review:
    base_branches:
      - 'main'
  path_instructions:
    - path: '**/*.java'
      instructions: |
        All the code for the annotation processor should be checked, please.

        Please do these:
        * Review code using Java 21 standards, taking into account the vague rules and samples defined in `CONTRIBUTING.md`
        * Validate that code indentation uses spaces, not tabs, with an indent of multiple of 4
        * Propose changes using Java 21 API
        
        Language used is British English (en-GB).

        Please keep in mind:
        * The pattern matching `instanceof` expression safely handles `null`, returning `false`
        * Java 21 prefers the use of `HashSet.newHashSet(int size)` over the constructor
        * Our rule is that builds must be reproducible, and the annotation processor must not prevent a consuming build from being reproducible
        * We would like to avoid adding additional `required` dependencies, but we are happy to detect if a library is present to generate code and those can be added as optional
    - path: 'utils-tests/**/*.java'
      instructions: |
        This folder, including "main" files, are all for the purpose of testing. This is because an annotation processor can only really be tested by applying it to a build

        Coding standards can be relaxed a little here, as the code isn't published and isn't used by anyone except for tests. 
        
        We also don't have to be "formal" with the content - using references for test content is fine.
    - path: 'advanced-record-utils-annotations/**/*.java'
      instructions: |
        This is the user-facing part of the library. It must be well-documented

        For the code:
        * When providing defaults for the annotation values, we have some rules that should be enforced:
           * Principle of Least Astonishment
           * Dependencies are not required
        * Non-default values may add dependency requirements - these should be documented (and added as optional to the pom)
    - path: 'aru-prism-prison/**'
      instructions: |
        The README of `aru-prism-prison` covers this folder quite well
    - path: 'docs/**'
      instructions: |
        Our comprehensive documentation. These are bundled into one large page and published to GitHub Pages.
        
        Language should generally use a formal (though not "stuffy") tone - a small amount of humour is desirable, but not too much.
        It should use British English (en-GB), and serial/Oxford comma unless it would introduce ambiguity.

        References to the "generated-code" folder all exist and will resolve, but the contents of that folder have been hidden from you.
        This is because the folder is full of "noise" that makes it hard for you to review.

        Please ensure that we stick to the intended use of warning and caution:
         * Use CAUTION to advise the reader to act carefully (i.e., exercise care).
         * Use WARNING to inform the reader of danger, harm, or consequences that exist.
        
        There are other style items listed in the `docs/README.adoc` file - please ensure they are followed.
    - path: 'aru-processor-core/**/*.java'
      instructions: |
        This folder contains the dense code that wires together the processor. The `module-info` specifies that the code is `@NullMarked`, therefore
          if code is added that can put `null` somewhere that isn't explicitly annotated as `Nullable` it should be called out.

        As per `CONTRIBUTING.md`, this folder should really only have:
          * The minimum to achieve that goal; and
          * The "core" of the builder

        While it should be possible to make all the code readable, if any part of the codebase is going to be hard to read it is likely to be in here.
        Changes here will have the largest impact, and should be well-understood. The code here should also be documented for contributors adding to the
        processors capabilities (the documentation is *not* intended for end-users of the annotation processor, although hopefully it would make sense to them too!)
    - path: 'advanced-record-utils-processor/**/*.java'
      instructions: |
        This is the "worker" part of the codebase.

        Ideally, everything in here follows a similar pattern (minus the Constants file) to the `aru-processor-core`:
         * How "specific" the worker is at doing work
         * Testing if it should attempt the work in a general sense (e.g. dependencies, settings)
         * Then, when doing the work:
            * Test any remaining specifics (e.g. component-level stuff)
            * Do the work

        Because this is an annotation processor, tests should be included by adding modules/records to the `utils-tests` and should include positive and negative cases
          * The design of the project may mean that the "negative" case isn't explicit, but is tested elsewhere. The positive case should definitely be tested though!

        The documentation here is a little more sparse, which isn't great but the aim is that each item should mostly be self-contained or should have a relationship with a
          small parent that helps out with the context of the work. If it's a parent class, an interface, or if the class is something used in multiple places, those must be documented.

        The `module-info` specifies that the code is `@NullMarked`, therefore if code is added that can put `null` somewhere that isn't explicitly annotated as `Nullable` 
           it should be called out. The `module-info` file is new, so there may be some `package-info` files with `NullMarked` - those are no longer required thanks to
           the new `module-info` file.
