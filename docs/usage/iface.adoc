= Interfaces

Advanced Record Utils can handle the use of interfaces in a tree of records that use/reference each other.

Take the following structure:

WARNING: This is to give you a baseline for the following content - doing exactly this will not work as you expect!

.SomeInterface.java
[source,java]
----
public interface SomeInterface {
}
----

.MyRecordFOptionA.java
[source,java]
----
public record MyRecordFOptionA(
    String someStrField
) implements SomeInterface {
}
----

.MyRecordFOptionB.java
[source,java]
----
public record MyRecordFOptionB(
    int someIntField
) implements SomeInterface {
}
----

.MyRecordG.java
[source,java]
----
@AdvancedRecordUtils
public record MyRecordG(
    SomeInterface anInterface
) {}
----

As described above, the processor is not able to work with the `+SomeInterface+` interface, and so will not generate `+*Utils+` classes for the two implementing records, nor will there be builder methods (such as fluent setters) for them. This also applies to any other utilities generated - no mergers or differs - and so those tools will fall back to default methods of working.

There are several approaches that can be used to resolve this.

== Seal the interface

If you change the definition of the interface so that it is sealed, like so:

.SomeInterface.java
[source,java]
----
public sealed interface SomeInterface
permits MyRecordFOptionA, MyRecordFOptionB {
}
----

.MyRecordFOptionA.java
[source,java]
----
public record MyRecordFOptionA(
    String someStrField
) implements SomeInterface {
}
----

.MyRecordFOptionB.java
[source,java]
----
public record MyRecordFOptionB(
    int someIntField
) implements SomeInterface {
}
----

.MyRecordG.java
[source,java]
----
@AdvancedRecordUtils
public record MyRecordG(
    SomeInterface anInterface
) {}
----

Then the processor will be able to read the `+permits+` clause and the cascading ability will build `+*Utils+` classes for:

* `+SomeInterface+`
* `+MyRecordFOptionA+`
* `+MyRecordFOptionB+`

include::../generated-code/usage/iface-generated.adoc[]

== Annotate the records

If you annotate the records that implement the interface as well as `+MyRecordG+` like so:

.SomeInterface.java
[source,java]
----
public interface SomeInterface {
}
----

.MyRecordFOptionA.java
[source,java]
----
@AdvancedRecordUtils
public record MyRecordFOptionA(
    String someStrField
) implements SomeInterface {
}
----

.MyRecordFOptionB.java
[source,java]
----
@AdvancedRecordUtils
public record MyRecordFOptionB(
    int someIntField
) implements SomeInterface {
}
----

.MyRecordG.java
[source,java]
----
@AdvancedRecordUtils
public record MyRecordG(
    SomeInterface anInterface
) {}
----

Then when the processor reads the interface defined on both of the records it is able to incorporate it into its internal workflows. This means it will build `+*Utils+` classes for:

* `+SomeInterface+`
* `+MyRecordFOptionA+`
* `+MyRecordFOptionB+`

NOTE: The below collapsible is the same as the one under "Seal the interface"

include::../generated-code/usage/iface-generated.adoc[]

CAUTION: If you only annotate one of the records, then a `+*Utils+` class won't be generated for the omitted record, and both the interface's and `+MyRecordG+` generated `+*Utils+` classes will only be able to reference the one record

== Annotations from serialisation libraries

If you are using various libraries, you can use their annotations to inform the processor as to implementations of an interface.

=== Jakarta XML Bindings

If you are using Jakarta's XML Binding annotations, you can use either:

* `+@XmlSeeAlso+` on the interface, listing the implementing records
* `+@XmlElements+` on a component, listing the implementing records

=== Jackson

If you are using Jackson, you can use an `+@JsonSubTypes+` on the interface, listing the implementing records.

CAUTION: As of version 0.6.1, the processor doesn't process the annotation on record components.

=== Avaje Jsonb

If you are using Avaje's Jsonb, you can use an `+@Json.SubTypes+` on the interface, listing the implementing records.

== Use package-wide application

If you annotate the package that contains the structure like so:

.package-info.java
[source,java]
----
@io.github.cbarlin.aru.annotations.AdvancedRecordUtils(applyToAllInPackage = true)
package org.example;
----

.SomeInterface.java
[source,java]
----
public interface SomeInterface{
}
----

.MyRecordFOptionA.java
[source,java]
----
public record MyRecordFOptionA(
    String someStrField
) implements SomeInterface {
}
----

.MyRecordFOptionB.java
[source,java]
----
public record MyRecordFOptionB(
    int someIntField
) implements SomeInterface {
}
----

.MyRecordG.java
[source,java]
----
public record MyRecordG(
    SomeInterface anInterface
) {}
----

Then when the processor reads the interface defined on both of the records it is able to incorporate it into its internal workflows. This means it will build `+*Utils+` classes for:

* `+SomeInterface+`
* `+MyRecordFOptionA+`
* `+MyRecordFOptionB+`

NOTE: The below collapsible is the same as the one under "Seal the interface"

include::../generated-code/usage/iface-generated.adoc[]