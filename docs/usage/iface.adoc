= Interfaces

Advanced Record Utils can handle the use of interfaces in a tree of records that use/reference each other.

Take the following structure:

WARNING: This is to give you a baseline for the following content - doing exactly this will not work as you expect!

[source,java]
----
public interface SomeInterface {
}

public record MyRecordFOptionA(
    String someStrField
) implements SomeInterface {
}

public record MyRecordFOptionB(
    int someIntField
) implements SomeInterface {
}

@AdvancedRecordUtils
public record MyRecordG(
    SomeInterface anInterface
) {}
----

As described above, the processor is not able to work with the `+SomeInterface+` interface, and so will not generate `+*Utils+` classes for the two implementing records, nor will there be builder methods (such as fluent setters) for them. This also applies to any other utilities generated - no mergers or differs - and so those tools will fall back to default methods of working.

There are several approaches that can be used to resolve this.

== Seal the interface

If you change the definition of the interface so that it is sealed, like so:

[source,java]
----
public sealed interface SomeInterface permits MyRecordFOptionA, MyRecordFOptionB {
}

public record MyRecordFOptionA(
    String someStrField
) implements SomeInterface {
}

public record MyRecordFOptionB(
    int someIntField
) implements SomeInterface {
}

@AdvancedRecordUtils
public record MyRecordG(
    SomeInterface anInterface
) {}
----

Then the processor will be able to read the `+permits+` clause and the cascading ability will build `+*Utils+` classes for:

* `+SomeInterface+`
* `+MyRecordFOptionA+`
* `+MyRecordFOptionB+`

include::../generated-code/usage/iface-generated.adoc[]

== Annotate the records

If you annotate the records that implement the interface as well as `+MyRecordG+` like so:

[source,java]
----
public interface SomeInterface {
}

@AdvancedRecordUtils
public record MyRecordFOptionA(
    String someStrField
) implements SomeInterface {
}

@AdvancedRecordUtils
public record MyRecordFOptionB(
    int someIntField
) implements SomeInterface {
}

@AdvancedRecordUtils
public record MyRecordG(
    SomeInterface anInterface
) {}
----

Then when the processor reads the interface defined on both of the records it is able to incorporate it into its internal workflows. This means it will build `+*Utils+` classes for:

* `+SomeInterface+`
* `+MyRecordFOptionA+`
* `+MyRecordFOptionB+`

NOTE: The below collapsible is the same as the one under "Seal the interface"

include::../generated-code/usage/iface-generated.adoc[]

CAUTION: If you only annotate one of the records, then a `+*Utils+` class won't be generated for the omitted record, and both the interface's and `+MyRecordG+` generated `+*Utils+` classes will only be able to reference the one record

== Use package-wide application

If you annotate the package that contains the structure like so:

[source,java]
----
@io.github.cbarlin.aru.annotations.AdvancedRecordUtils(applyToAllInPackage = true)
package org.example;

public interface SomeInterface {
}

public record MyRecordFOptionA(
    String someStrField
) implements SomeInterface {
}

public record MyRecordFOptionB(
    int someIntField
) implements SomeInterface {
}

public record MyRecordG(
    SomeInterface anInterface
) {}
----

Then when the processor reads the interface defined on both of the records it is able to incorporate it into its internal workflows. This means it will build `+*Utils+` classes for:

* `+SomeInterface+`
* `+MyRecordFOptionA+`
* `+MyRecordFOptionB+`

NOTE: The below collapsible is the same as the one under "Seal the interface"

include::../generated-code/usage/iface-generated.adoc[]