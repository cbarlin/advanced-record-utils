= Generation options

.`+fluent+`
[%collapsible]
====
Determine if fluent versions of methods should be built. These are methods that take a lambda with a single argument, which is the referenced type's builder.

*Type*:: `+boolean+`
*Default*:: `+"true"+`

// This would be difficult to convey in multiple blocks, so we'll leave it in one

.Usage
[source,java]
----
@AdvancedRecordUtils(
    builderOptions = @BuilderOptions(
        fluent = false
    )
)
public record Person(Address address, List<PhoneNumber> phoneNumbers) {}

public record Address(String country) {}

public record PhoneNumber(String number) {}
----

With the default setting of `+true+`, you can set the "address" field like so:

.Sample method body
[source,java]
----
PersonUtils.builder()
    .address(addressBuilder -> addressBuilder.country("Australia"));
----

You can also add to the "phoneNumbers" field (assuming you haven't disabled that functionality) like so:

.Sample method body
[source,java]
----
PersonUtils.builder()
    .addPhoneNumbers(builder -> builder.number("04 4444 4444"));
----

The processor also handles self-referencing types easily. Take the following definition:

.MyRecordB.java
[source,java]
----
@AdvancedRecordUtils(merger = true)
public record MyRecordB(
    String aField,
    MyRecordB recursionFtw // The processor deals with self-referencing types
) {

}
----

You can then do:

.Sample method body
[source,java]
----
MyRecordBUtils.builder()
    .recursionFtw(
        b1 -> b1.aField("Nesting 1")
            .recursionFtw(
                b2 -> b2.aField("Nesting 2")
                    .recursionFtw(
                        b3 -> b3.aField("Nesting 3")
                    )
            )
    );
----

include::../../generated-code/options/builder-generation-fluent.adoc[]

====

.`+createAdderMethods+`
[%collapsible]
====
Should "add"-er type methods be created on the Builder?

*Type*:: `+boolean+`
*Default*:: `+"true"+`

// This would be difficult to convey in multiple blocks, so we'll leave it in one

.Usage
[source,java]
----
@AdvancedRecordUtils(
    builderOptions = @BuilderOptions(
        createAdderMethods = false
    )
)
public record Person(Address address, List<PhoneNumber> phoneNumbers) {}

public record Address(String country) {}

public record PhoneNumber(String number) {}
----

With the default setting of `+true+`, you can add to the "phoneNumbers" field like so:

.Sample method body
[source,java]
----
PersonUtils.builder()
    .addPhoneNumbers(new PhoneNumber("04 4444 4444"));
----

include::../../generated-code/options/builder-generation-adder.adoc[]

====

.`+nullReplacesNotNull+`
[%collapsible]
====
Should the builder allow setting a "null" value if there's already a non-null value?

*Type*:: `+boolean+`
*Default*:: `+"true"+`

// This would be difficult to convey in multiple blocks, so we'll leave it in one

.Usage
[source,java]
----
@AdvancedRecordUtils(
    builderOptions = @BuilderOptions(
        nullReplacesNotNull = false
    )
)
public record Person(Address address, List<PhoneNumber> phoneNumbers) {}

public record Address(String country) {}

public record PhoneNumber(String number) {}
----

If you set this to `+false+`, the below will pass:

.Sample method body
[source,java]
----
PersonUtils.Builder builder = PersonUtils.builder()
    .address(new Address("Australia"))
    .address(null);
// It's not null on the builder object
Objects.requireNonNull(builder.address());
// And it's not null when built
Objects.requireNonNull(builder.build().address());
----

include::../../generated-code/options/builder-generation-nullrepl.adoc[]

====

.`+builtCollectionType+`
[%collapsible]
====
If the Builder points to a generic collection type (such as `+List+` or `+Set+`), what should the builder construct when building?

NOTE: If you define a concrete type the Builder will attempt to respect that type (e.g. specifying a `+LinkedList+`).

*Type*:: https://javadoc.io/doc/io.github.cbarlin/advanced-record-utils-annotations/latest/io.github.cbarlin.aru.annotations/io/github/cbarlin/aru/annotations/AdvancedRecordUtils.BuiltCollectionType.html[`+BuiltCollectionType+`^]
*Default*:: `+BuiltCollectionType.JAVA_IMMUTABLE+`

// This would be difficult to convey in multiple blocks, so we'll leave it in one

.Usage
[source,java]
----
@AdvancedRecordUtils(
    builderOptions = @BuilderOptions(
        builtCollectionType = AdvancedRecordUtils.BuiltCollectionType.AUTO
    )
)
public record Person(Address address, List<PhoneNumber> phoneNumbers, Set<String> names) {}

public record Address(String country) {}

public record PhoneNumber(String number) {}
----

It has the following values:

* `+AUTO+` - the collection will be whatever type is passed into the builder, unless you attempt to call an "add"-er method, in which case a sane default will be chosen (`+ArrayList+`, `+HashSet+`, etc)
* `+JAVA_IMMUTABLE+` - the resulting collection will always be immutable

include::../../generated-code/options/builder-generation-collection.adoc[]

====

.`+buildNullCollectionToEmpty+`
[%collapsible]
====
If the Builder is going to result in a `+null+` value for a collection, should we instead return an empty collection?

*Type*:: `+boolean+`
*Default*:: `+true+`

// This would be difficult to convey in multiple blocks, so we'll leave it in one

.Usage
[source,java]
----
@AdvancedRecordUtils(
    builderOptions = @BuilderOptions(
        buildNullCollectionToEmpty = false
    )
)
public record Person(Address address, List<PhoneNumber> phoneNumbers) {}

public record Address(String country) {}

public record PhoneNumber(String number) {}
----

NOTE: Instead of modifying the "getter" for the builder, this instead modifies the default value of the internal field when the builder is constructed as well as the "setter" to have different behaviour if you pass in `+null+`.

include::../../generated-code/options/builder-generation-nullcollection.adoc[]

====

.`+setTimeNowMethods+`
[%collapsible]
====
Should the builder contain methods that automatically set `+OffsetDateTime+`, `+ZonedDateTime+`, and `+LocalDateTime+` to the current time?

*Type*:: `+boolean+`
*Default*:: `+true+`

.Usage
[source,java]
----
@AdvancedRecordUtils(
    builderOptions = @BuilderOptions(
        setTimeNowMethods = false
    )
)
public record Person(
    OffsetDateTime offsetDateTime,
    ZonedDateTime zonedDateTime,
    LocalDateTime localDateTime
) {
}
----

include::../../generated-code/options/builder-generation-settime.adoc[]

====

.`+setToNullMethods+`
[%collapsible]
====

Should the builder generate methods to explicitly reset a field to a “null-like” state?

The result of the method is:

* empty for `+Optional+` components
* empty for collection components when `+buildNullCollectionToEmpty+` is `+true+`
* `+null+` for all other component types.

*Type*:: `+boolean+`
*Default*:: `+false+`

CAUTION: When `nullReplacesNotNull = false`, these `setXToNull` methods will not be generated at all.

.Usage
[source,java]
----
@AdvancedRecordUtils(
    builderOptions = @AdvancedRecordUtils.BuilderOptions(
        setToNullMethods = true
    )
)
public record Person(
    OffsetDateTime offsetDateTime,
    List<String> tags,
    String name
) { }
----

include::../../generated-code/options/builder-generation-setnull.adoc[]

====

.`+concreteSettersForOptional+`
[%collapsible]
====
If an optional type is used, should there be a setter that takes the concrete type?

*Type*:: `+boolean+`
*Default*:: `+true+`

.Usage
[source,java]
----
@AdvancedRecordUtils(
    builderOptions = @BuilderOptions(
        concreteSettersForOptional = false
    )
)
public record Person(
    OptionalInt age,
    Optional<String> surname
) {
}
----

If set to `+true+` (default), you are able to do the following:

.Sample method body
[source,java]
----
PersonUtils.builder()
    .age(42)
    .surname((String) null);
----

include::../../generated-code/options/builder-generation-optional.adoc[]

====

[#options-builder-generation-validated]
.`+validatedBuilder+`
[%collapsible]
====
Should there be versions of the build methods that validate the built item?

*Type*:: https://javadoc.io/doc/io.github.cbarlin/advanced-record-utils-annotations/latest/io.github.cbarlin.aru.annotations/io/github/cbarlin/aru/annotations/AdvancedRecordUtils.ValidationApi.html[`+ValidationApi+`^]
*Default*:: `+ValidationApi.NONE+`

.Usage
[source,java]
----
@AdvancedRecordUtils(
    builderOptions = @BuilderOptions(
        validatedBuilder = ValidationApi.AVAJE
    )
)
public record Person(
    @NonNull @NotBlank @Size(max = 50)
    String name
) {
}
----

There are three possible values, with the default `+NONE+` not generating any additional methods.

NOTE: Use of any value other than `+NONE+` will need the necessary dependencies.

The value of `+JAKARTA_PLAIN+` generates methods that allow you to use Jakarta's validation API directly in order to validate the built object like so:

.Sample method body
[source,java]
----
Validator validator = obtainValidator(); // You will need a validator
PersonUtils.builder()
    .build(
        validator,
        (Set<Set<ConstraintViolation<Person>>> violations) -> {
            // This method is only called if there's at least one violation
        }
    );
// Alternatively, you can do:
PersonUtils.builder()
    .build(
        validator,
        (Set<Set<ConstraintViolation<Person>>> violations, Person personThatWasBuilt) -> {
            // This method is always called
        }
    );
----

The value of `+AVAJE+` generates methods that allows you to use the https://avaje.io/validator/[Avaje Validator^]. You can use it like so:

.Sample method body
[source,java]
----
Validator validator = obtainValidator(); // You will need a validator
PersonUtils.Builder builder = PersonUtils.builder();
try {
    // These use your validator:
    builder.build(validator);
    builder.build(validator, GroupA.class, GroupB.class);
    // These use the default validator
    builder.buildAndValidate();
    builder.buildAndValidate(GroupA.class, GroupB.class);
    // And you can still use the original builder:
    builder.build();
} catch (ConstraintViolationException e) {
    // Do something with the violations
}
----

include::../../generated-code/options/builder-generation-validator.adoc[]

====

.`+mapStructValidatesWithAvaje+`
[%collapsible]
====
When using both the Avaje validator (see <<#options-builder-generation-validated,validation settings>>) and MapStruct, should we request that MapStruct calls the method that uses the default validator?

*Type*:: `+boolean+`
*Default*:: `+false+`

.Usage
[source,java]
----
@AdvancedRecordUtils(
    builderOptions = @BuilderOptions(
        validatedBuilder = ValidationApi.AVAJE,
        mapStructValidatesWithAvaje = true
    )
)
@Valid
public record Person(
    @NonNull @NotBlank @Size(max = 50)
    String name
) {
}
----

When set to `+true+` and the "buildAndValidate" method has been created then the MapStruct integration will call that method. If false, or if there's no "buildAndValidate" method, then it will use the default "build" method.

====

.`+delayNestedBuild+`
[%collapsible]
====
Determine if nested records should be built immediately/eagerly (default), or built as part of the getter/building methods on the outer builder.

*Type*:: `+boolean+`
*Default*:: `+"false"+`

// This would be difficult to convey in multiple blocks, so we'll leave it in one

.Usage
[source,java]
----
@AdvancedRecordUtils(
    builderOptions = @BuilderOptions(
        delayNestedBuild = true
    )
)
public record Person(Address address) {}

public record Address(String country, String state, String postCode) {}
----

If you were to do the following:

.Sample method body
[source,java]
----
PersonUtils.builder()
    .address(addressBuilder -> addressBuilder.country("Australia"))
    .address(addressBuilder -> addressBuilder.state("QLD"))
    .address(addressBuilder -> addressBuilder.state("ACT"))
    .address(addressBuilder -> addressBuilder.state("NT"))
    .address(addressBuilder -> addressBuilder.state("NSW"));
----

With the default value of `+false+`, the above code leads to (approximately) the equivalent of this:

.Sample method body
[source,java]
----
var ab1 = AddressUtils.builder();
ab1.country("Australia");
var a1 = ab1.build();
var ab2 = AddressUtils.builder(a1);
ab2.state("QLD");
var a2 = ab2.build();
var ab3 = AddressUtils.builder(a2);
ab3.state("ACT");
var a3 = ab3.build();
var ab4 = AddressUtils.builder(a3);
ab4.state("NT");
var a4 = ab4.build()
var ab5 = AddressUtils.builder(a4);
ab5.state("NSW");
var a5 = ab5.build();
----

Which isn't overly efficient. When setting the value to `+true+`, the above code would be the same as:

.Sample method body
[source,java]
----
PersonUtils.builder()
    .address(addressBuilder -> addressBuilder.country("Australia")
                                             .state("QLD")
                                             .state("ACT")
                                             .state("NT")
                                             .state("NSW"));
----

Which is much more efficient. However, this does come with the negative that taking the "root" element of a deeply nested structure and converting back to the builder will convert all non-collection elements in the tree back into builders, which can also be an expensive operation. Depending on your usage of withers and mergers, this can occur quite often.

====