package io.github.cbarlin.aru.tests.xml_util;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertNotNull;

import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.function.Consumer;

import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamWriter;
import javax.xml.transform.Source;

import io.github.cbarlin.aru.annotations.Generated;
import org.apache.commons.io.output.StringBuilderWriter;
import org.apache.commons.io.output.WriterOutputStream;
import org.xmlunit.assertj3.XmlAssert;
import org.xmlunit.builder.Input;

public final class ConvertToXml {

    @Generated("CONSTRUCTOR_STATIC_CLASS")
    private ConvertToXml() {
        throw new UnsupportedOperationException("This is a utility class and cannot be instantiated");
    }

    /**
     * Compare XML generated by the consumer to the file provided
     * @param consumer A method that writes to the stream writer
     * @param classPathCompareFile The file in the class path to compare the XML against
     */
    public static final void compareXml(final Consumer<XMLStreamWriter> consumer, final String classPathCompareFile) {
        compareXml(consumer, classPathCompareFile, ConvertToXml.class);
    }

    /**
     * Compare XML generated by the consumer to the file provided
     * @param consumer A method that writes to the stream writer
     * @param classPathCompareFile The file in the class path to compare the XML against
     * @param clazz The class whose classloader to use
     */
    public static final void compareXml(final Consumer<XMLStreamWriter> consumer, final String classPathCompareFile, final Class<?> clazz) {
        final String actual = assertDoesNotThrow(() -> convertToXml(consumer));
        final Source expected = loadClasspath(classPathCompareFile, clazz);
        XmlAssert.assertThat(actual).and(expected)
            .ignoreWhitespace()
            .ignoreComments()
            .areIdentical();
    }

    /**
     * Take a method that writes to an XML Stream and read the resulting string.
     * <p>
     * Will open and close the XML Document for you
     * @param consumer The method that will write to the XML Stream
     * @return A string with all the XML content
     * @throws IOException In the event that content cannot be written
     * @throws XMLStreamException In the event there's a problem with the XML
     */
    public static final String convertToXml(final Consumer<XMLStreamWriter> consumer) throws IOException, XMLStreamException {
        final StringBuilder xmlStringBuilder = new StringBuilder();
        final XMLOutputFactory factory = XMLOutputFactory.newFactory();
        factory.setProperty(XMLOutputFactory.IS_REPAIRING_NAMESPACES, true);
        try (
            final StringBuilderWriter stringBuilderWriter = new StringBuilderWriter(xmlStringBuilder);
            final WriterOutputStream ws = WriterOutputStream.builder()
                .setWriter(stringBuilderWriter)
                .setCharset(StandardCharsets.UTF_8)
                .get();
        ) {
            final XMLStreamWriter streamWriter = factory.createXMLStreamWriter(ws, StandardCharsets.UTF_8.name());
            streamWriter.writeStartDocument();
            consumer.accept(streamWriter);
            streamWriter.writeEndDocument();
            // Flush and close the XML streams because apparently xml doesn't have autocloseable...
            streamWriter.flush();
            streamWriter.close();
            ws.flush();
            stringBuilderWriter.flush();
            return xmlStringBuilder.toString();
        }
    }

    /**
     * Load an XML File from the classpath
     * @param classPathPath The path on the classpath to load
     * @return The XML File
     */
    public static final Source loadClasspath(final String classPathPath) {
        return loadClasspath(classPathPath, ConvertToXml.class);
    }

    /**
     * Load an XML File from the classpath
     * @param classPathPath The path on the classpath to load
     * @param clazz The class whose classloader we should use
     * @return The XML File
     */
    public static final Source loadClasspath(final String classPathPath, final Class<?> clazz) {
        final InputStream resourceAsStream = assertDoesNotThrow(() -> clazz.getClassLoader().getResourceAsStream(classPathPath));
        assertNotNull(resourceAsStream);
        return Input.fromStream(resourceAsStream).build();
    }
}
